/**
 * @file Firestore Security Rules for MÃ£eTech Conecta
 * @version 2
 *
 * @Core Philosophy: This ruleset enforces a strict user-ownership model for personal data and shared access for chats, combined with public read access for marketplace items and content, with owner-only writes. Administrative privileges are managed via a dedicated "roles_admin" collection.
 *
 * @Data Structure:
 * - /users/{userId}: User profile data, owned by the user.
 * - /marketplace_items/{marketplaceItemId}: Marketplace items, publicly readable, but writable only by the owner.
 * - /content/{contentId}: Content such as videos or forum posts, publicly readable, but writable only by the owner.
 * - /matches/{matchId}: Social matches between users.
 * - /users/{userId}/chats/{chatId}/messages/{messageId}: Chat messages, accessible only to the participants of the chat.
 * - /users/{userId}/subscriptions/{subscriptionId}: User subscriptions, owned by the user.
 * - /roles_admin/{userId}: Administrative roles, granting elevated privileges to specific users.
 *
 * @Key Security Decisions:
 * - User profiles and subscriptions are strictly owned by the user, enforced through path-based rules.
 * - Marketplace items and content are publicly readable to enable discovery but writable only by the owner (author/seller).
 * - Chat messages are only accessible to the participants of the chat, verified by checking the user ID against the document path.
 * - Listing of user profiles is disallowed to protect user privacy.
 * - Administrative privileges are granted based on the existence of a document in the `/roles_admin/{userId}` collection.
 *
 * @Denormalization for Authorization:
 * - MarketplaceItem: Uses sellerId to determine the owner.
 * - Content: Uses authorId to determine the owner.
 * - ChatMessage: The hierarchical path /users/{userId}/chats/{chatId}/messages/{messageId} allows for path-based authorization, inferring ownership from the location of the document.
 *
 * @Structural Segregation:
 * - User-specific data (profiles, subscriptions, chats) is stored under the /users/{userId} path to enable easy enforcement of ownership.
 * - Publicly readable data (marketplace items, content) is stored in top-level collections with owner-only write access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the existing resource.
     *              Also verifies that the resource exists to prevent modification of non-existent documents.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the authenticated user has admin privileges.
     *              Admin privileges are granted if a document exists in the /roles_admin/{userId} collection
     */
    function isAdmin() {
        return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * @description Rules for user profiles.
     * @path /users/{userId}
     * @allow (create) - Authenticated user can create their own profile if the userId matches their auth.uid.
     * @allow (get, update, delete) - Authenticated user can only access their own profile.
     * @deny (create) - Non-authenticated user cannot create a profile.
     * @deny (update, delete) - Authenticated user cannot modify another user's profile.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Do not allow listing of user profiles for privacy.
      allow create: if isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for marketplace items.
     * @path /marketplace_items/{marketplaceItemId}
     * @allow (get, list) - Anyone can read marketplace items.
     * @allow (create) - Only authenticated users can create marketplace items.
     * @allow (update, delete) - Only the owner (seller) can update or delete the item.
     * @deny (create) - If sellerId does not match the authenticated user's ID.
     * @principle Allows public read with owner-only writes.
     */
    match /marketplace_items/{marketplaceItemId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.sellerId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.sellerId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.sellerId == request.auth.uid && resource != null;
    }

    /**
     * @description Rules for content.
     * @path /content/{contentId}
     * @allow (get, list) - Anyone can read content.
     * @allow (create) - Only authenticated users can create content.
     * @allow (update, delete) - Only the owner (author) can update or delete the content.
     * @deny (create) - If authorId does not match the authenticated user's ID.
     * @principle Allows public read with owner-only writes.
     */
    match /content/{contentId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
    }

    /**
     * @description Rules for matches.
     * @path /matches/{matchId}
     * @allow get: if isSignedIn(); // TODO: Implement more restrictive access based on user1Id and user2Id
     * @allow list: if false; // Listing matches is not allowed for privacy.
     * @allow create: if isSignedIn(); // TODO: Implement more restrictive access based on user1Id and user2Id
     * @allow update: if false; // Updating matches is not allowed.
     * @allow delete: if false; // Deleting matches is not allowed.
     * @principle Restricts match data access.
     */
    match /matches/{matchId} {
      allow get: if isSignedIn(); // TODO: Implement more restrictive access based on user1Id and user2Id
      allow list: if false; // Listing matches is not allowed for privacy.
      allow create: if isSignedIn(); // TODO: Implement more restrictive access based on user1Id and user2Id
      allow update: if false; // Updating matches is not allowed.
      allow delete: if false; // Deleting matches is not allowed.
    }

    /**
     * @description Rules for chat messages within a user's chat.
     * @path /users/{userId}/chats/{chatId}/messages/{messageId}
     * @allow (get, list) - Only the owner (the user in the path) can read chat messages.
     * @allow (create) - Only the owner (the user in the path) can create chat messages.
     * @allow (update, delete) - No one can update or delete chat messages.
     * @principle Restricts chat messages access to the chat participants.
     */
    match /users/{userId}/chats/{chatId}/messages/{messageId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.senderId == request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rules for user subscriptions.
     * @path /users/{userId}/subscriptions/{subscriptionId}
     * @allow (get, list) - Only the owner (the user in the path) can read their own subscription.
     * @allow (create) - Only the owner (the user in the path) can create their own subscription.
     * @allow (update, delete) - Only the owner can update or delete their own subscription.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/subscriptions/{subscriptionId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for admin roles.
     * @path /roles_admin/{userId}
     * @allow get: if isAdmin();
     * @allow list: if false;
     * @allow create: if isAdmin();
     * @allow update: if false;
     * @allow delete: if isAdmin();
     * @principle Restricts creation, deletion, and modification of admin roles to existing admins.
     */
    match /roles_admin/{userId} {
        allow get: if isAdmin();
        allow list: if false;
        allow create: if isAdmin();
        allow update: if false;
        allow delete: if isAdmin();
    }
  }
}